# 内存池项目

## 目的

- 参考卡码网的内存池项目复写一个版本，以此来学习该项目

## 需求

- 对象大小是否固定，是否在一个可控区间内？
- 对象的数量是否可控？是否动态可控？
- 申请后的内存是否可回收？是否可动态回收？
- 尽量减少内部碎片，让分配的内存块尽量贴近需求的大小

- 对象大小不固定，对于在一定区间内的小对象，采用内存池分配方案；超出区间的大对象，采用new直接分配的方案
- 线程池，全局只能有一个，所以必须是单例模式
- 相同大小的空闲内存链放在一起

## API设计

示例1：
优点：可以根据对象大小，随意调整尺寸；对象的构造一起做了
缺点：需要准备多种尺寸大小
```C++
Object* obj = newObj(Object, params...);
deleteObj(obj);
```

示例2：根据对象大小分配内存，构建不做（不推荐）
```C++
void* p = mallocObj(size_t size);
```

示例3：只生产一种对象，只不过这些对象是放在内存池中的
这种得话，直接使用克隆模式实现是不是更好
```C++
Object* obj = newObj(params...);
```

示例4：只生产几种对象，可以根据大小、对象编号、对象名来创建
这种是简单工厂模式，不推荐
```C++
Object* obj = newObj(ObjID, params...)
```

# 测试标准

1. 功能测试
    - 单线程（正常流程、边界检测）
        - 申请各种大小的对象（参考Slot大小）
            0byte，1byte
            7byte，8byte，9byte
            16byte，32byte，64byte，128byte，256byte，512byte
            513byte
        - 申请各种数量的对象（参考Block大小，以8byte为单位）
            1个block：1个，2个，512个
            2个block：
            4个block：
            上限：512个block
        - 验证1个Block可以申请的对象数量
        - 内存复用检测
    - 多线程
        - 线程安全
            - ABA问题
2. 性能测试
    综合性能必须跑赢new/delete，测试出优势的地方，输出性能报告
    - 单线程
        1. 场景1：
    - 多线程

# 存在问题

1. 处理ABA问题，导致内存池性能弱于原生new/delete
2. 不处理ABA问题，单线程性能更强，但线程不安全，无法执行多线程操作
3. Benchmark测试用例中，多个用例共享一个单例内存池，对结果会有影响
